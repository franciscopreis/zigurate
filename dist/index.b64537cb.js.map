{"mappings":"ACqGA,SAAS,EAAY,CAAS,CAAE,CAAS,EACvC,IAAI,EAAM,SAAS,oBAAoB,CAAC,KACpC,EAAM,EAAI,MAAM,CAGpB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,IACvB,CAAG,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,CAAG,EACrB,CAAG,CAAC,EAAE,CAAC,KAAK,CAAC,eAAe,CAAG,CAEnC,CAGA,MAAM,EAAW,SAAS,aAAa,CAAC,OAyNxC,GAxNA,EAAS,GAAG,CAAG,4BAwNX,AAAmC,KAAA,GAAnC,aAAa,OAAO,CAAC,WACvB,EAAY,QAAS,SACrB,EAAS,GAAG,CAAG,gCAEV,CAKL,IAAI,EAAQ,AAHU,aAAa,OAAO,CAAC,WAGf,KAAK,CAAC,KAC9B,EAAY,CAAK,CAAC,EAAE,CACpB,EAAQ,CAAK,CAAC,EAAE,CAGpB,EAAY,EAAO,GACnB,EAAS,GAAG,CAAG,CAAC,gBAAgB,EAAE,EAAM,IAAI,CAAC,AAC/C,CAII,AAAoC,uBAApC,aAAa,OAAO,CAAC,cACvB,AApIF,WACE,IAAI,EAAQ,SAAS,sBAAsB,CAAC,WACxC,EAAQ,SAAS,cAAc,CAAC,cAGpC,GAAI,AAAmD,CAAA,GAAnD,EAAM,SAAS,CAAC,QAAQ,CAAC,uBAC3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,WAAW,GAC9B,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,oBAC1B,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,GAAG,CAAC,uBACvB,aAAa,OAAO,CAAC,WAAY,4BAE9B,GAAI,AAAmD,CAAA,GAAnD,EAAM,SAAS,CAAC,QAAQ,CAAC,uBAClC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,WAAW,GAC9B,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,uBAC1B,aAAa,OAAO,CAAC,WAAY,OAGvC,IAkHE,QAAQ,GAAG,CAAC,aAAa,OAAO,CAAC,cACY,oBAApC,aAAa,OAAO,CAAC,eAC9B,AAjHF,WACE,IAAI,EAAQ,SAAS,sBAAsB,CAAC,WACxC,EAAQ,SAAS,cAAc,CAAC,cAGpC,GAAI,AAAgD,CAAA,GAAhD,EAAM,SAAS,CAAC,QAAQ,CAAC,oBAC3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,WAAW,GAC9B,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,uBAC1B,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,GAAG,CAAC,oBACvB,aAAa,OAAO,CAAC,WAAY,yBAE9B,GAAI,AAAgD,CAAA,GAAhD,EAAM,SAAS,CAAC,QAAQ,CAAC,oBAClC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,WAAW,GAC9B,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,oBAC1B,aAAa,OAAO,CAAC,WAAY,OAGvC,IA+FE,QAAQ,GAAG,CAAC,aAAa,OAAO,CAAC","sources":["<anon>","src/zigurate.js"],"sourcesContent":["//MAPEAMENTO das permutas para criptografia\nconst mapeamento = {\n    //minusculas\n    a: \"o\",\n    \"\\xe1\": \"\\xf3\",\n    \"\\xe0\": \"\\xf2\",\n    \"\\xe2\": \"\\xf4\",\n    \"\\xe3\": \"\\xf5\",\n    b: \"p\",\n    c: \"g\",\n    d: \"t\",\n    e: \"i\",\n    \"\\xe9\": \"\\xed\",\n    \"\\xe8\": \"\\xec\",\n    \"\\xea\": \"\\xee\",\n    \\u1EBD: \"\\u0129\",\n    f: \"v\",\n    g: \"c\",\n    h: \"h\",\n    i: \"e\",\n    \"\\xed\": \"\\xe9\",\n    \"\\xec\": \"\\xe8\",\n    \\u0129: \"\\u1EBD\",\n    \"\\xee\": \"\\xea\",\n    j: \"j\",\n    k: \"q\",\n    l: \"r\",\n    m: \"n\",\n    n: \"m\",\n    o: \"a\",\n    \"\\xf3\": \"\\xe1\",\n    \"\\xf2\": \"\\xe0\",\n    \"\\xf5\": \"\\xe3\",\n    \"\\xf4\": \"\\xe2\",\n    p: \"b\",\n    q: \"k\",\n    r: \"l\",\n    s: \"z\",\n    t: \"d\",\n    u: \"u\",\n    v: \"f\",\n    w: \"w\",\n    x: \"x\",\n    y: \"y\",\n    z: \"s\",\n    //maiusculas\n    A: \"O\",\n    \"\\xc1\": \"\\xd3\",\n    \"\\xc0\": \"\\xd2\",\n    \"\\xc2\": \"\\xd4\",\n    \"\\xc3\": \"\\xd5\",\n    B: \"P\",\n    C: \"G\",\n    D: \"T\",\n    E: \"I\",\n    \"\\xc9\": \"\\xcd\",\n    \"\\xc8\": \"\\xcc\",\n    \"\\xca\": \"\\xce\",\n    \\u1EBC: \"\\u0128\",\n    F: \"V\",\n    G: \"C\",\n    H: \"H\",\n    I: \"E\",\n    \"\\xcd\": \"\\xc9\",\n    \"\\xcd\": \"\\xcd\",\n    \\u0128: \"\\u1EBC\",\n    J: \"J\",\n    K: \"Q\",\n    L: \"R\",\n    M: \"N\",\n    N: \"M\",\n    O: \"A\",\n    \"\\xd3\": \"\\xc1\",\n    \"\\xd2\": \"\\xc0\",\n    \"\\xd5\": \"\\xc3\",\n    \"\\xd4\": \"\\xc2\",\n    P: \"B\",\n    Q: \"K\",\n    R: \"L\",\n    S: \"Z\",\n    T: \"D\",\n    U: \"U\",\n    V: \"F\",\n    W: \"W\",\n    X: \"X\",\n    Y: \"Y\",\n    Z: \"S\"\n};\n//ARRAY com colors dos esquemas de cor\nlet colors = [\n    \"white\",\n    \"red\",\n    \"gold\",\n    \"blue\",\n    \"green\",\n    \"purple\",\n    \"black\"\n];\n//COR: função que aplica a cor de acordo\nfunction colorSwitch(textColor, bckgColor) {\n    let all = document.getElementsByTagName(\"*\");\n    let max = all.length;\n    //Aplicamos um loop\n    for(let i = 0; i < max; i++){\n        all[i].style.color = textColor;\n        all[i].style.backgroundColor = bckgColor;\n    }\n}\n//IMAGEM: imagem do zigurate default como black\nconst zigurate = document.querySelector(\"img\");\nzigurate.src = \"images/ziggurat-black.png\";\n//COLORSCHEME: Aplica os vários estilos de acordo com uma bckgColor definida\nlet count = 0;\nfunction colorScheme(bckgColor) {\n    //Excluir o elemento bckgColor do arranjo colors pois não queremos que ambos coincidam\n    if (colors.length == 7) {\n        let index = colors.indexOf(bckgColor);\n        colors.splice(index, 1);\n        console.log(colors);\n    }\n    //A variável newCount é criada para conseguir obter o colors[0]\n    count++;\n    let newCount = count - 1;\n    let max = colors.length - 1;\n    //no último elemento voltar ao zero para manter um \"loop\"\n    //alteração de zigurate.src muda a imagem\n    if (colors[newCount] === colors[max]) {\n        zigurate.src = `images/ziggurat-${colors[newCount]}.png`;\n        colorSwitch(colors[newCount], bckgColor);\n        count = 0;\n        colors.push(bckgColor) //adicionar de novo o elemento bckgColor para passarmos ao passo anterior caso outro botão seja carregado\n        ;\n    } else {\n        colorSwitch(colors[newCount], bckgColor);\n        zigurate.src = `images/ziggurat-${colors[newCount]}.png`;\n        //esta parte é para facilitar a parte do localstorage para evitar repetições\n        let modo = bckgColor + \"-\" + colors[newCount];\n        localStorage.setItem(\"modoCor\", `${modo}`);\n        colors.push(bckgColor) //adicionar de novo o elemento bckgColor para passarmos ao passo anterior caso outro botão seja carregado\n        ;\n    }\n}\n//Assim basta criar novas funções para aplicar aos botões\nfunction white() {\n    colorScheme(\"white\");\n}\nfunction red() {\n    colorScheme(\"red\");\n}\nfunction gold() {\n    colorScheme(\"gold\");\n}\nfunction blue() {\n    colorScheme(\"blue\");\n}\nfunction green() {\n    colorScheme(\"green\");\n}\nfunction purple() {\n    colorScheme(\"purple\");\n}\nfunction black() {\n    colorScheme(\"black\");\n}\n//Função auxiliar que muda o texto de acordo com o\nfunction substituirLetrasTexto(texto, mapeamento) {\n    let novoTexto = \"\";\n    for(let i = 0; i < texto.length; i++){\n        const letra = texto[i];\n        const letraSubstituta = mapeamento[letra] || letra;\n        novoTexto += letraSubstituta;\n    }\n    return novoTexto;\n}\n//Simplificação cripto para z_texto.html\n//CRIPTO: aplica apenas ao texto do editor de texto\nfunction criptoTxt() {\n    const textoOriginal = document.getElementById(\"texto-original\").value;\n    const novoTexto = substituirLetrasTexto(textoOriginal, mapeamento);\n    document.getElementById(\"texto-modificado\").textContent = novoTexto;\n    //Esta função dá default aos estilos caso tenham sido carregados outros botões\n    document.getElementById(\"texto-modificado\").classList.remove(\"ideograma-bilateral\");\n    document.getElementById(\"texto-modificado\").classList.remove(\"ideograma-radial\");\n}\n//Este conversor está associado ao botão que converte todo o texto existente (marcado em html com a class \"display\") de acordo com o mapeamento criptográfico;\nfunction criptoAll() {\n    let texto = document.getElementsByClassName(\"display\");\n    //A utilização do loop for permite a iteração desta função em cada elemento presente no arranjo de elementos da classe \"display\"\n    for(let i = 0; i < texto.length; i++)texto[i].innerText = substituirLetrasTexto(texto[i].innerText, mapeamento);\n    let inputTexto = document.getElementById(\"texto-original\");\n    inputTexto.classList.remove(\"ideograma-bilateral\");\n}\n//TESTE\n//TEXTO IDEOGRAMÁTICO\n//Esta parte é referente à mudança de estilos de letras (ou \"fonts\") em dois tipos: ideograma bilateral e ideograma radial.\n//BILATERAL: Função que muda para font bilateral em TODO o texto\nfunction bilateralAll() {\n    let texto = document.getElementsByClassName(\"display\");\n    let title = document.getElementById(\"title-text\");\n    //As condições são definidas tendo em conta a presença ou não da class \"ideograma-bilateral\", de modo a que o botão possa activar e desactivar o modo;\n    if (title.classList.contains(\"ideograma-bilateral\") == false) for(let i = 0; i < texto.length; i++){\n        texto[i].innerHTML.toUpperCase();\n        texto[i].classList.remove(\"ideograma-radial\");\n        texto[i].classList.add(\"ideograma-bilateral\");\n        localStorage.setItem(\"modoFont\", \"ideograma-bilateral\");\n    }\n    else if (title.classList.contains(\"ideograma-bilateral\") == true) for(let i = 0; i < texto.length; i++){\n        texto[i].innerHTML.toLowerCase();\n        texto[i].classList.remove(\"ideograma-bilateral\");\n        localStorage.setItem(\"modoFont\", \"none\");\n    }\n}\n//RADIAL: Função que muda para font radial em TODO o texto\nfunction radialAll() {\n    let texto = document.getElementsByClassName(\"display\");\n    let title = document.getElementById(\"title-text\");\n    //As condições são definidas tendo em conta a presença ou não da class \"ideograma-bilateral\", de modo a que o botão possa activar e desactivar o modo;\n    if (title.classList.contains(\"ideograma-radial\") == false) for(let i = 0; i < texto.length; i++){\n        texto[i].innerHTML.toUpperCase();\n        texto[i].classList.remove(\"ideograma-bilateral\");\n        texto[i].classList.add(\"ideograma-radial\");\n        localStorage.setItem(\"modoFont\", \"ideograma-radial\");\n    }\n    else if (title.classList.contains(\"ideograma-radial\") == true) for(let i = 0; i < texto.length; i++){\n        texto[i].innerHTML.toLowerCase();\n        texto[i].classList.remove(\"ideograma-radial\");\n        localStorage.setItem(\"modoFont\", \"none\");\n    }\n}\n//BILATERAL para o editor de texto\nfunction bilateralTxt() {\n    document.getElementById(\"texto-modificado\").classList.remove(\"ideograma-radial\");\n    let inputTexto = document.getElementById(\"texto-original\").value;\n    let outputTexto = document.getElementById(\"texto-modificado\");\n    outputTexto.classList.add(\"ideograma-bilateral\");\n    outputTexto.textContent = inputTexto;\n}\n//BOTÃO RADIAL para o editor de texto\nfunction radialTxt() {\n    document.getElementById(\"texto-modificado\").classList.remove(\"ideograma-bilateral\");\n    let inputTexto = document.getElementById(\"texto-original\").value;\n    let outputTexto = document.getElementById(\"texto-modificado\");\n    outputTexto.classList.add(\"ideograma-radial\");\n    outputTexto.textContent = inputTexto;\n}\n//Botão que determina o tamanho\nfunction sizeAll() {\n    let all = document.getElementsByTagName(\"*\");\n    let max = all.length;\n    //Aplicamos um loop para aplicarmos a todos os elementos visíveis\n    for(let i = 0; i < max; i++){\n        all[i].style.transform = \"rotate(7deg)\" //testar 90deg\n        ;\n        console.log(count);\n    }\n}\nlet intervalID;\nfunction startColorChanging() {\n    if (!intervalID) intervalID = setInterval(function() {\n        let color1 = colors[Math.floor(Math.random() * colors.length)];\n        let color2 = colors[Math.floor(Math.random() * colors.length)];\n        if (color1 == color2) return colorSwitch(black, white);\n        else colorSwitch(color1, color2);\n    }, 200) // Intervalo de 5 segundos (5000 milissegundos)\n    ;\n    else {\n        clearInterval(intervalID);\n        intervalID = null;\n    // Restaurar cores originais se desejar\n    // colorSwitch(corOriginal1, corOriginal2);\n    }\n}\n//LOCALSTORAGE: gravar modos\n//MODOS DE COR\nif (localStorage.getItem(\"modoCor\") == undefined) {\n    colorSwitch(\"black\", \"white\");\n    zigurate.src = \"images/ziggurat-black.png\";\n//caso não exista nada no localStorage aplicar o default\n} else {\n    //ir buscar o modo guardado\n    let colorSchemeSave = localStorage.getItem(\"modoCor\");\n    //dividir em array de modo a separar as cores pelo hifen\n    let array = colorSchemeSave.split(\"-\");\n    let bckgColor = array[0];\n    let color = array[1];\n    //aplicar colorSwitch()\n    colorSwitch(color, bckgColor);\n    zigurate.src = `images/ziggurat-${color}.png`;\n}\n//MODOS DE FONT\nif (localStorage.getItem(\"modoFont\") == \"ideograma-bilateral\") {\n    bilateralAll();\n    console.log(localStorage.getItem(\"modoFont\"));\n} else if (localStorage.getItem(\"modoFont\") == \"ideograma-radial\") {\n    radialAll();\n    console.log(localStorage.getItem(\"modoFont\"));\n}\n// if (localStorage.getItem(\"modoFont\" == \"ideograma-bilateral\")) {\n//   function bilateralAll();\n// }else if(localStorage.getItem(\"modoFont\" == \"ideograma-radial\")){\n//   function radialAll();\n// }else{\n//   let nome = 0;\n// }\n//SAVE TXT\nfunction download(filename, text) {\n    var element = document.createElement(\"a\");\n    element.setAttribute(\"href\", \"data:text/plain;charset=utf-8,\" + encodeURIComponent(text));\n    element.setAttribute(\"download\", filename);\n    element.style.display = \"none\";\n    document.body.appendChild(element);\n    element.click();\n    document.body.removeChild(element);\n}\n// Start file download.\nfunction downloadFile() {\n    // Corrige a obtenção dos textos para usar .value em vez de .textContent\n    let textoOriginal = document.getElementById(\"texto-original\").value;\n    let textoModificado = document.getElementById(\"texto-modificado\").value;\n    // Preparar o conteúdo para download\n    let content = `Input:\\n${textoOriginal}\\n\\nOutput:\\n${textoModificado}`;\n    let filename = \"zigurate.txt\";\n    let blob = new Blob([\n        content\n    ], {\n        type: \"text/plain;charset=utf-8\"\n    });\n    // Cria um link de download\n    let link = document.createElement(\"a\");\n    link.href = URL.createObjectURL(blob);\n    link.download = filename;\n    // Simula um clique no link para iniciar o download\n    document.body.appendChild(link) // Adiciona o link ao corpo do documento para garantir a compatibilidade\n    ;\n    link.click();\n    document.body.removeChild(link) // Remove o link após o clique\n    ;\n    // Libera o objeto URL\n    URL.revokeObjectURL(link.href);\n}\n\n//# sourceMappingURL=index.b64537cb.js.map\n","//MAPEAMENTO das permutas para criptografia\nconst mapeamento = {\n  //minusculas\n  a: 'o',\n  á: 'ó',\n  à: 'ò',\n  â: 'ô',\n  ã: 'õ',\n\n  b: 'p',\n  c: 'g',\n  d: 't',\n  e: 'i',\n  é: 'í',\n  è: 'ì',\n  ê: 'î',\n  ẽ: 'ĩ',\n\n  f: 'v',\n  g: 'c',\n  h: 'h',\n  i: 'e',\n  í: 'é',\n  ì: 'è',\n  ĩ: 'ẽ',\n  î: 'ê',\n  j: 'j',\n  k: 'q',\n  l: 'r',\n  m: 'n',\n  n: 'm',\n  o: 'a',\n  ó: 'á',\n  ò: 'à',\n  õ: 'ã',\n  ô: 'â',\n\n  p: 'b',\n  q: 'k',\n  r: 'l',\n  s: 'z',\n  t: 'd',\n  u: 'u',\n  v: 'f',\n  w: 'w',\n  x: 'x',\n  y: 'y',\n  z: 's',\n\n  //maiusculas\n  A: 'O',\n  Á: 'Ó',\n  À: 'Ò',\n  Â: 'Ô',\n  Ã: 'Õ',\n\n  B: 'P',\n  C: 'G',\n  D: 'T',\n  E: 'I',\n  É: 'Í',\n  È: 'Ì',\n  Ê: 'Î',\n  Ẽ: 'Ĩ',\n\n  F: 'V',\n  G: 'C',\n  H: 'H',\n  I: 'E',\n  Í: 'É',\n  Í: 'Í',\n  Ĩ: 'Ẽ',\n\n  J: 'J',\n  K: 'Q',\n  L: 'R',\n  M: 'N',\n  N: 'M',\n  O: 'A',\n  Ó: 'Á',\n  Ò: 'À',\n  Õ: 'Ã',\n  Ô: 'Â',\n\n  P: 'B',\n  Q: 'K',\n  R: 'L',\n  S: 'Z',\n  T: 'D',\n  U: 'U',\n  V: 'F',\n  W: 'W',\n  X: 'X',\n  Y: 'Y',\n  Z: 'S',\n}\n\n//ARRAY com colors dos esquemas de cor\nlet colors = ['white', 'red', 'gold', 'blue', 'green', 'purple', 'black']\n\n//COR: função que aplica a cor de acordo\nfunction colorSwitch(textColor, bckgColor) {\n  let all = document.getElementsByTagName('*')\n  let max = all.length\n\n  //Aplicamos um loop\n  for (let i = 0; i < max; i++) {\n    all[i].style.color = textColor\n    all[i].style.backgroundColor = bckgColor\n  }\n}\n\n//IMAGEM: imagem do zigurate default como black\nconst zigurate = document.querySelector('img')\nzigurate.src = 'images/ziggurat-black.png'\n\n//COLORSCHEME: Aplica os vários estilos de acordo com uma bckgColor definida\n\nlet count = 0\nfunction colorScheme(bckgColor) {\n  //Excluir o elemento bckgColor do arranjo colors pois não queremos que ambos coincidam\n  if (colors.length == 7) {\n    let index = colors.indexOf(bckgColor)\n    colors.splice(index, 1)\n    console.log(colors)\n  }\n  //A variável newCount é criada para conseguir obter o colors[0]\n  count++\n  let newCount = count - 1\n  let max = colors.length - 1\n\n  //no último elemento voltar ao zero para manter um \"loop\"\n  //alteração de zigurate.src muda a imagem\n  if (colors[newCount] === colors[max]) {\n    zigurate.src = `images/ziggurat-${colors[newCount]}.png`\n    colorSwitch(colors[newCount], bckgColor)\n    count = 0\n    colors.push(bckgColor) //adicionar de novo o elemento bckgColor para passarmos ao passo anterior caso outro botão seja carregado\n  } else {\n    colorSwitch(colors[newCount], bckgColor)\n    zigurate.src = `images/ziggurat-${colors[newCount]}.png`\n\n    //esta parte é para facilitar a parte do localstorage para evitar repetições\n    let modo = bckgColor + '-' + colors[newCount]\n    localStorage.setItem('modoCor', `${modo}`)\n    colors.push(bckgColor) //adicionar de novo o elemento bckgColor para passarmos ao passo anterior caso outro botão seja carregado\n  }\n}\n//Assim basta criar novas funções para aplicar aos botões\nfunction white() {\n  colorScheme('white')\n}\nfunction red() {\n  colorScheme('red')\n}\nfunction gold() {\n  colorScheme('gold')\n}\nfunction blue() {\n  colorScheme('blue')\n}\nfunction green() {\n  colorScheme('green')\n}\nfunction purple() {\n  colorScheme('purple')\n}\nfunction black() {\n  colorScheme('black')\n}\n\n//Função auxiliar que muda o texto de acordo com o\nfunction substituirLetrasTexto(texto, mapeamento) {\n  let novoTexto = ''\n  for (let i = 0; i < texto.length; i++) {\n    const letra = texto[i]\n    const letraSubstituta = mapeamento[letra] || letra\n    novoTexto += letraSubstituta\n  }\n  return novoTexto\n}\n\n//Simplificação cripto para z_texto.html\n\n//CRIPTO: aplica apenas ao texto do editor de texto\nfunction criptoTxt() {\n  const textoOriginal = document.getElementById('texto-original').value\n  const novoTexto = substituirLetrasTexto(textoOriginal, mapeamento)\n  document.getElementById('texto-modificado').textContent = novoTexto\n\n  //Esta função dá default aos estilos caso tenham sido carregados outros botões\n  document\n    .getElementById('texto-modificado')\n    .classList.remove('ideograma-bilateral')\n  document\n    .getElementById('texto-modificado')\n    .classList.remove('ideograma-radial')\n}\n\n//Este conversor está associado ao botão que converte todo o texto existente (marcado em html com a class \"display\") de acordo com o mapeamento criptográfico;\nfunction criptoAll() {\n  let texto = document.getElementsByClassName('display')\n\n  //A utilização do loop for permite a iteração desta função em cada elemento presente no arranjo de elementos da classe \"display\"\n  for (let i = 0; i < texto.length; i++) {\n    texto[i].innerText = substituirLetrasTexto(texto[i].innerText, mapeamento)\n  }\n\n  let inputTexto = document.getElementById('texto-original')\n  inputTexto.classList.remove('ideograma-bilateral')\n}\n\n//TESTE\n\n//TEXTO IDEOGRAMÁTICO\n//Esta parte é referente à mudança de estilos de letras (ou \"fonts\") em dois tipos: ideograma bilateral e ideograma radial.\n\n//BILATERAL: Função que muda para font bilateral em TODO o texto\n\nfunction bilateralAll() {\n  let texto = document.getElementsByClassName('display')\n  let title = document.getElementById('title-text')\n\n  //As condições são definidas tendo em conta a presença ou não da class \"ideograma-bilateral\", de modo a que o botão possa activar e desactivar o modo;\n  if (title.classList.contains('ideograma-bilateral') == false) {\n    for (let i = 0; i < texto.length; i++) {\n      texto[i].innerHTML.toUpperCase()\n      texto[i].classList.remove('ideograma-radial')\n      texto[i].classList.add('ideograma-bilateral')\n      localStorage.setItem('modoFont', 'ideograma-bilateral')\n    }\n  } else if (title.classList.contains('ideograma-bilateral') == true) {\n    for (let i = 0; i < texto.length; i++) {\n      texto[i].innerHTML.toLowerCase()\n      texto[i].classList.remove('ideograma-bilateral')\n      localStorage.setItem('modoFont', 'none')\n    }\n  }\n}\n\n//RADIAL: Função que muda para font radial em TODO o texto\nfunction radialAll() {\n  let texto = document.getElementsByClassName('display')\n  let title = document.getElementById('title-text')\n\n  //As condições são definidas tendo em conta a presença ou não da class \"ideograma-bilateral\", de modo a que o botão possa activar e desactivar o modo;\n  if (title.classList.contains('ideograma-radial') == false) {\n    for (let i = 0; i < texto.length; i++) {\n      texto[i].innerHTML.toUpperCase()\n      texto[i].classList.remove('ideograma-bilateral')\n      texto[i].classList.add('ideograma-radial')\n      localStorage.setItem('modoFont', 'ideograma-radial')\n    }\n  } else if (title.classList.contains('ideograma-radial') == true) {\n    for (let i = 0; i < texto.length; i++) {\n      texto[i].innerHTML.toLowerCase()\n      texto[i].classList.remove('ideograma-radial')\n      localStorage.setItem('modoFont', 'none')\n    }\n  }\n}\n\n//BILATERAL para o editor de texto\n\nfunction bilateralTxt() {\n  document\n    .getElementById('texto-modificado')\n    .classList.remove('ideograma-radial')\n\n  let inputTexto = document.getElementById('texto-original').value\n\n  let outputTexto = document.getElementById('texto-modificado')\n\n  outputTexto.classList.add('ideograma-bilateral')\n\n  outputTexto.textContent = inputTexto\n}\n\n//BOTÃO RADIAL para o editor de texto\n\nfunction radialTxt() {\n  document\n    .getElementById('texto-modificado')\n    .classList.remove('ideograma-bilateral')\n\n  let inputTexto = document.getElementById('texto-original').value\n\n  let outputTexto = document.getElementById('texto-modificado')\n\n  outputTexto.classList.add('ideograma-radial')\n\n  outputTexto.textContent = inputTexto\n}\n\n//Botão que determina o tamanho\nfunction sizeAll() {\n  let all = document.getElementsByTagName('*')\n  let max = all.length\n\n  //Aplicamos um loop para aplicarmos a todos os elementos visíveis\n  for (let i = 0; i < max; i++) {\n    all[i].style.transform = 'rotate(7deg)' //testar 90deg\n    console.log(count)\n  }\n}\n\nlet intervalID\n\nfunction startColorChanging() {\n  if (!intervalID) {\n    intervalID = setInterval(function () {\n      let color1 = colors[Math.floor(Math.random() * colors.length)]\n      let color2 = colors[Math.floor(Math.random() * colors.length)]\n\n      if (color1 == color2) {\n        return colorSwitch(black, white)\n      } else {\n        colorSwitch(color1, color2)\n      }\n    }, 200) // Intervalo de 5 segundos (5000 milissegundos)\n  } else {\n    clearInterval(intervalID)\n    intervalID = null\n    // Restaurar cores originais se desejar\n    // colorSwitch(corOriginal1, corOriginal2);\n  }\n}\n//LOCALSTORAGE: gravar modos\n\n//MODOS DE COR\nif (localStorage.getItem('modoCor') == undefined) {\n  colorSwitch('black', 'white')\n  zigurate.src = 'images/ziggurat-black.png'\n  //caso não exista nada no localStorage aplicar o default\n} else {\n  //ir buscar o modo guardado\n  let colorSchemeSave = localStorage.getItem('modoCor')\n\n  //dividir em array de modo a separar as cores pelo hifen\n  let array = colorSchemeSave.split('-')\n  let bckgColor = array[0]\n  let color = array[1]\n\n  //aplicar colorSwitch()\n  colorSwitch(color, bckgColor)\n  zigurate.src = `images/ziggurat-${color}.png`\n}\n\n//MODOS DE FONT\n\nif (localStorage.getItem('modoFont') == 'ideograma-bilateral') {\n  bilateralAll()\n  console.log(localStorage.getItem('modoFont'))\n} else if (localStorage.getItem('modoFont') == 'ideograma-radial') {\n  radialAll()\n  console.log(localStorage.getItem('modoFont'))\n}\n\n// if (localStorage.getItem(\"modoFont\" == \"ideograma-bilateral\")) {\n//   function bilateralAll();\n// }else if(localStorage.getItem(\"modoFont\" == \"ideograma-radial\")){\n//   function radialAll();\n// }else{\n//   let nome = 0;\n// }\n\n//SAVE TXT\n\nfunction download(filename, text) {\n  var element = document.createElement('a')\n  element.setAttribute(\n    'href',\n    'data:text/plain;charset=utf-8,' + encodeURIComponent(text)\n  )\n  element.setAttribute('download', filename)\n\n  element.style.display = 'none'\n  document.body.appendChild(element)\n\n  element.click()\n\n  document.body.removeChild(element)\n}\n\n// Start file download.\n\nfunction downloadFile() {\n  // Corrige a obtenção dos textos para usar .value em vez de .textContent\n  let textoOriginal = document.getElementById('texto-original').value\n  let textoModificado = document.getElementById('texto-modificado').value\n\n  // Preparar o conteúdo para download\n  let content = `Input:\\n${textoOriginal}\\n\\nOutput:\\n${textoModificado}`\n\n  let filename = 'zigurate.txt'\n\n  let blob = new Blob([content], {\n    type: 'text/plain;charset=utf-8',\n  })\n\n  // Cria um link de download\n  let link = document.createElement('a')\n  link.href = URL.createObjectURL(blob)\n  link.download = filename\n\n  // Simula um clique no link para iniciar o download\n  document.body.appendChild(link) // Adiciona o link ao corpo do documento para garantir a compatibilidade\n  link.click()\n  document.body.removeChild(link) // Remove o link após o clique\n\n  // Libera o objeto URL\n  URL.revokeObjectURL(link.href)\n}\n"],"names":["colorSwitch","textColor","bckgColor","all","document","getElementsByTagName","max","length","i","style","color","backgroundColor","zigurate","querySelector","src","localStorage","undefined","getItem","array","colorSchemeSave","split","bilateralAll","texto","getElementsByClassName","title","getElementById","classList","contains","innerHTML","toUpperCase","remove","add","setItem","toLowerCase","console","log","radialAll"],"version":3,"file":"index.b64537cb.js.map"}